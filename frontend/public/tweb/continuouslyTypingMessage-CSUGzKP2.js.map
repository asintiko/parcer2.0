{"version":3,"file":"continuouslyTypingMessage-CSUGzKP2.js","sources":["../src/components/chat/bubbleParts/continuouslyTypingMessage.ts"],"sourcesContent":["import {animate} from '../../../helpers/animation';\r\nimport styles from './continuouslyTypingMessage.module.scss';\r\n\r\n\r\ntype WrapContinuouslyTypingMessageArgs = {\r\n  root: Node;\r\n  bubble: HTMLElement;\r\n  scrollable: HTMLElement;\r\n  isEnd?: boolean;\r\n  prevPosition?: number;\r\n};\r\n\r\ntype Result = {\r\n  allNodes: Node[];\r\n  bubble: HTMLElement;\r\n  clean: () => void;\r\n  currentPosition: number;\r\n  currentNodeIdx: number;\r\n  nextIsEnd?: boolean;\r\n};\r\n\r\nexport function wrapContinuouslyTypingMessage({root, bubble, scrollable, isEnd = false, prevPosition = -1}: WrapContinuouslyTypingMessageArgs): Result {\r\n  const {\r\n    maxPosition,\r\n    nodeContents,\r\n    allNodes,\r\n    currentNodeIdx\r\n  } = processNodeTree({root, prevPosition});\r\n\r\n  let\r\n    lastTextNode: Node,\r\n    cleaned = false,\r\n    ended = false\r\n  ;\r\n\r\n  function clean() {\r\n    cleaned = true;\r\n    allNodes.forEach(node => nodeContents.delete(node));\r\n  };\r\n\r\n  function onEnd() {\r\n    if(ended) return;\r\n    ended = true;\r\n\r\n    if(!isEnd) appendDots(lastTextNode);\r\n  }\r\n\r\n  const result = {\r\n    allNodes,\r\n    bubble,\r\n    clean,\r\n    currentPosition: prevPosition,\r\n    currentNodeIdx,\r\n    nextIsEnd: isEnd\r\n  };\r\n\r\n  runAnimation({\r\n    scrollable,\r\n    typeNext: (length) => typeNext({\r\n      result,\r\n      setLastTextNode: (node) => lastTextNode = node,\r\n      nodeContents,\r\n      onEnd,\r\n      length\r\n    }),\r\n    isCleaned: () => cleaned,\r\n    maxPosition,\r\n    prevPosition\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n\r\ntype ProcessNodeTreeArgs = {\r\n  root: Node;\r\n  prevPosition: number;\r\n};\r\n\r\nfunction processNodeTree({root, prevPosition}: ProcessNodeTreeArgs) {\r\n  const treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_ALL);\r\n\r\n  const allNodes: Node[] = [];\r\n  const nodeContents = new WeakMap<Node, string>();\r\n\r\n  while(treeWalker.nextNode()) allNodes.push(treeWalker.currentNode);\r\n\r\n  let\r\n    position = -1,\r\n    currentNodeIdx = 0\r\n  ;\r\n\r\n  for(const node of allNodes) {\r\n    if(node.nodeType === Node.TEXT_NODE) {\r\n      nodeContents.set(node, node.textContent);\r\n\r\n      node.textContent = node.textContent.slice(0, Math.max(0, prevPosition - position + 1));\r\n\r\n      position += nodeContents.get(node).length;\r\n    } else if(node instanceof Element && position > prevPosition) {\r\n      node.classList.add(styles.hidden);\r\n    }\r\n\r\n    if(position <= prevPosition) {\r\n      currentNodeIdx++;\r\n    }\r\n  }\r\n\r\n  return {maxPosition: position, nodeContents, allNodes, currentNodeIdx};\r\n}\r\n\r\n\r\nfunction appendDots(node: Node) {\r\n  const parent = node.parentNode;\r\n  if(!(parent instanceof Element)) return;\r\n\r\n  const dots = document.createElement('span');\r\n  dots.className = styles.Dots;\r\n  dots.textContent = ' ';\r\n\r\n  new Array(3).fill(null).forEach((_, idx) => {\r\n    const dot = document.createElement('span');\r\n    dot.textContent = '.';\r\n    dot.classList.add(styles.Dot, styles['Dot' + (idx + 1)]);\r\n    dots.appendChild(dot);\r\n  });\r\n\r\n  parent.appendChild(dots);\r\n}\r\n\r\n\r\ntype TypeNextArgs = {\r\n  result: Result;\r\n  setLastTextNode: (node: Node) => void;\r\n  onEnd: () => void;\r\n  nodeContents: WeakMap<Node, string>;\r\n  length: number;\r\n};\r\n\r\nfunction typeNext({result, setLastTextNode, onEnd, nodeContents, length}: TypeNextArgs) {\r\n  const {allNodes, clean} = result;\r\n\r\n  while(result.currentNodeIdx < allNodes.length && length) {\r\n    const node = allNodes[result.currentNodeIdx];\r\n\r\n    if(node instanceof Element) {\r\n      result.currentNodeIdx++;\r\n      node.classList.remove(styles.hidden);\r\n    } else if(node.nodeType === Node.TEXT_NODE) {\r\n      const typedLength = node.textContent.length;\r\n      const finalContent = nodeContents.get(node);\r\n\r\n      const leftOverLength = Math.max(0, typedLength + length - finalContent.length);\r\n\r\n      const start = typedLength;\r\n      const end = start + length - leftOverLength;\r\n\r\n      node.textContent += finalContent.slice(start, end);\r\n\r\n      length = leftOverLength;\r\n      result.currentPosition += end - start;\r\n\r\n      if(leftOverLength) result.currentNodeIdx++;\r\n      setLastTextNode(node);\r\n    }\r\n  }\r\n\r\n  if(result.currentNodeIdx >= allNodes.length) {\r\n    clean();\r\n    onEnd();\r\n  }\r\n}\r\n\r\n\r\nconst BASE_DELAY = 60 * 1_000 / (800 * 5); // 800wpm\r\nconst MIN_DELAY = 60 * 1_000 / (2_400 * 5); // 2_400wpm\r\nconst DELAY_VARIATION = 0.3;\r\n\r\n// Try to write it with the base speed of 800wpm or burst it in 5 seconds if it's a long message, maximum speed of 2_400wpm overall\r\nfunction getRandomDelay(targetDelay: number) {\r\n  const delay = Math.max(MIN_DELAY, Math.min(BASE_DELAY, targetDelay));\r\n  return delay + Math.random() * delay * DELAY_VARIATION;\r\n}\r\n\r\n\r\ntype RunAnimationArgs = {\r\n  scrollable: HTMLElement;\r\n  typeNext: (length: number) => void;\r\n  isCleaned: () => boolean;\r\n  maxPosition: number;\r\n  prevPosition: number;\r\n};\r\n\r\nconst TARGET_TIME_TO_WRITE = 5000;\r\n\r\nfunction runAnimation({scrollable, typeNext, isCleaned, maxPosition, prevPosition}: RunAnimationArgs) {\r\n  const targetDelay = TARGET_TIME_TO_WRITE / (maxPosition - prevPosition);\r\n\r\n  let prevTime = 0;\r\n\r\n  const animationInvalidation = registerAnimationInvalidation(scrollable);\r\n\r\n  const checkCleaned = () => {\r\n    if(!isCleaned()) return false;\r\n\r\n    animationInvalidation.cleanup();\r\n\r\n    return true;\r\n  };\r\n\r\n  let skip = -1;\r\n  const skipFrames = 2;\r\n\r\n  animate(() => {\r\n    if(checkCleaned()) return false;\r\n\r\n    skip = (skip + 1) % skipFrames;\r\n    if(skip) return true;\r\n\r\n    const now = performance.now();\r\n    if(!prevTime) prevTime = now;\r\n\r\n    const length = Math.max(0, Math.round((now - prevTime) / getRandomDelay(targetDelay)));\r\n\r\n    if(length) {\r\n      typeNext(length);\r\n      prevTime = now;\r\n    }\r\n\r\n    if(length && !animationInvalidation.isInvalidated()) {\r\n      // value.aboutToScroll = true;\r\n\r\n      // animate(() => {\r\n      // value.aboutToScroll = false;\r\n      // if(value.invalidateTimeoutId || checkCleaned()) return;\r\n\r\n      const threshold = 120; // px\r\n      if(scrollable.scrollTop + scrollable.clientHeight > scrollable.scrollHeight - threshold) {\r\n        scrollable.scrollTop = scrollable.scrollHeight;\r\n      }\r\n      // });\r\n    }\r\n\r\n    return true;\r\n  });\r\n}\r\n\r\n\r\ntype RegisteredScrollableValue = {\r\n  count: number;\r\n  invalidateTimeoutId?: number;\r\n  // aboutToScroll?: boolean;\r\n  cleanup: () => void;\r\n};\r\n\r\nconst INVALIDATE_SCROLL_TIMEOUT = 450;\r\n\r\nconst events = ['wheel', 'touchstart', 'pointerdown', 'keydown'] as const;\r\nconst registeredScrollables = new Map<HTMLElement, RegisteredScrollableValue>();\r\n\r\nfunction registerAnimationInvalidation(scrollable: HTMLElement) {\r\n  let value: RegisteredScrollableValue;\r\n\r\n  if(!registeredScrollables.has(scrollable)) {\r\n    value = {\r\n      count: 0,\r\n      cleanup: () => {\r\n        events.forEach(event => {\r\n          scrollable.removeEventListener(event, callback);\r\n        });\r\n      }\r\n    };\r\n\r\n    const callback = () => {\r\n      if(value.invalidateTimeoutId) self.clearTimeout(value.invalidateTimeoutId);\r\n      value.invalidateTimeoutId = self.setTimeout(() => {\r\n        value.invalidateTimeoutId = undefined;\r\n      }, INVALIDATE_SCROLL_TIMEOUT)\r\n    };\r\n\r\n    events.forEach(event => {\r\n      scrollable.addEventListener(event, callback, {passive: true});\r\n    });\r\n\r\n    registeredScrollables.set(scrollable, value);\r\n  } else {\r\n    value = registeredScrollables.get(scrollable);\r\n  }\r\n\r\n  value.count++;\r\n\r\n  let cleaned = false;\r\n\r\n  return {\r\n    isInvalidated: () => !!value.invalidateTimeoutId,\r\n    cleanup: () => {\r\n      if(cleaned) return;\r\n      cleaned = true;\r\n\r\n      value.count--;\r\n\r\n      if(value.count <= 0) {\r\n        value.cleanup();\r\n        registeredScrollables.delete(scrollable);\r\n      }\r\n    }\r\n  };\r\n}\r\n"],"names":["wrapContinuouslyTypingMessage","root","bubble","scrollable","isEnd","prevPosition","maxPosition","nodeContents","allNodes","currentNodeIdx","processNodeTree","lastTextNode","cleaned","ended","clean","node","onEnd","appendDots","result","runAnimation","length","typeNext","treeWalker","position","styles","parent","dots","_","idx","dot","setLastTextNode","typedLength","finalContent","leftOverLength","start","end","BASE_DELAY","MIN_DELAY","DELAY_VARIATION","getRandomDelay","targetDelay","delay","TARGET_TIME_TO_WRITE","isCleaned","prevTime","animationInvalidation","registerAnimationInvalidation","checkCleaned","skip","skipFrames","animate","now","INVALIDATE_SCROLL_TIMEOUT","events","registeredScrollables","value","event","callback"],"mappings":"mMAqBgB,SAAAA,EAA8B,CAAC,KAAAC,EAAM,OAAAC,EAAQ,WAAAC,EAAY,MAAAC,EAAQ,GAAO,aAAAC,EAAe,IAAgD,CAC/I,KAAA,CACJ,YAAAC,EACA,aAAAC,EACA,SAAAC,EACA,eAAAC,CACE,EAAAC,EAAgB,CAAC,KAAAT,EAAM,aAAAI,CAAa,CAAA,EAGtC,IAAAM,EACAC,EAAU,GACVC,EAAQ,GAGV,SAASC,GAAQ,CACLF,EAAA,GACVJ,EAAS,QAAQO,GAAQR,EAAa,OAAOQ,CAAI,CAAC,CACpD,CAEA,SAASC,GAAQ,CACZH,IACKA,EAAA,GAEJT,GAAOa,EAAWN,CAAY,EACpC,CAEA,MAAMO,EAAS,CACb,SAAAV,EACA,OAAAN,EACA,MAAAY,EACA,gBAAiBT,EACjB,eAAAI,EACA,UAAWL,CAAA,EAGA,OAAAe,EAAA,CACX,WAAAhB,EACA,SAAWiB,GAAWC,EAAS,CAC7B,OAAAH,EACA,gBAAkBH,GAASJ,EAAeI,EAC1C,aAAAR,EACA,MAAAS,EACA,OAAAI,CAAA,CACD,EACD,UAAW,IAAMR,EACjB,YAAAN,EACA,aAAAD,CAAA,CACD,EAEMa,CACT,CAQA,SAASR,EAAgB,CAAC,KAAAT,EAAM,aAAAI,GAAoC,CAClE,MAAMiB,EAAa,SAAS,iBAAiBrB,EAAM,WAAW,QAAQ,EAEhEO,EAAmB,CAAA,EACnBD,MAAmB,QAEzB,KAAMe,EAAW,SAAS,GAAYd,EAAA,KAAKc,EAAW,WAAW,EAG/D,IAAAC,EAAW,GACXd,EAAiB,EAGnB,UAAUM,KAAQP,EACbO,EAAK,WAAa,KAAK,WACXR,EAAA,IAAIQ,EAAMA,EAAK,WAAW,EAElCA,EAAA,YAAcA,EAAK,YAAY,MAAM,EAAG,KAAK,IAAI,EAAGV,EAAekB,EAAW,CAAC,CAAC,EAEzEA,GAAAhB,EAAa,IAAIQ,CAAI,EAAE,QAC3BA,aAAgB,SAAWQ,EAAWlB,GACzCU,EAAA,UAAU,IAAIS,EAAO,MAAM,EAG/BD,GAAYlB,GACbI,IAIJ,MAAO,CAAC,YAAac,EAAU,aAAAhB,EAAc,SAAAC,EAAU,eAAAC,CAAc,CACvE,CAGA,SAASQ,EAAWF,EAAY,CAC9B,MAAMU,EAASV,EAAK,WACpB,GAAG,EAAEU,aAAkB,SAAU,OAE3B,MAAAC,EAAO,SAAS,cAAc,MAAM,EAC1CA,EAAK,UAAYF,EAAO,KACxBE,EAAK,YAAc,IAEf,IAAA,MAAM,CAAC,EAAE,KAAK,IAAI,EAAE,QAAQ,CAACC,EAAGC,IAAQ,CACpC,MAAAC,EAAM,SAAS,cAAc,MAAM,EACzCA,EAAI,YAAc,IACdA,EAAA,UAAU,IAAIL,EAAO,IAAKA,EAAO,OAASI,EAAM,EAAE,CAAC,EACvDF,EAAK,YAAYG,CAAG,CAAA,CACrB,EAEDJ,EAAO,YAAYC,CAAI,CACzB,CAWA,SAASL,EAAS,CAAC,OAAAH,EAAQ,gBAAAY,EAAiB,MAAAd,EAAO,aAAAT,EAAc,OAAAa,GAAuB,CAChF,KAAA,CAAC,SAAAZ,EAAU,MAAAM,CAAS,EAAAI,EAE1B,KAAMA,EAAO,eAAiBV,EAAS,QAAUY,GAAQ,CACjD,MAAAL,EAAOP,EAASU,EAAO,cAAc,EAE3C,GAAGH,aAAgB,QACVG,EAAA,iBACFH,EAAA,UAAU,OAAOS,EAAO,MAAM,UAC3BT,EAAK,WAAa,KAAK,UAAW,CACpC,MAAAgB,EAAchB,EAAK,YAAY,OAC/BiB,EAAezB,EAAa,IAAIQ,CAAI,EAEpCkB,EAAiB,KAAK,IAAI,EAAGF,EAAcX,EAASY,EAAa,MAAM,EAEvEE,EAAQH,EACRI,EAAMD,EAAQd,EAASa,EAE7BlB,EAAK,aAAeiB,EAAa,MAAME,EAAOC,CAAG,EAExCf,EAAAa,EACTf,EAAO,iBAAmBiB,EAAMD,EAE7BD,GAAuBf,EAAA,iBAC1BY,EAAgBf,CAAI,CACtB,CACF,CAEGG,EAAO,gBAAkBV,EAAS,SAC7BM,IACAE,IAEV,CAGA,MAAMoB,EAAa,GAAK,KAAS,IAAM,GACjCC,EAAY,GAAK,KAAS,KAAQ,GAClCC,EAAkB,GAGxB,SAASC,EAAeC,EAAqB,CACrC,MAAAC,EAAQ,KAAK,IAAIJ,EAAW,KAAK,IAAID,EAAYI,CAAW,CAAC,EACnE,OAAOC,EAAQ,KAAK,OAAO,EAAIA,EAAQH,CACzC,CAWA,MAAMI,EAAuB,IAE7B,SAASvB,EAAa,CAAC,WAAAhB,EAAY,SAAAkB,EAAU,UAAAsB,EAAW,YAAArC,EAAa,aAAAD,GAAiC,CAC9F,MAAAmC,EAAcE,GAAwBpC,EAAcD,GAE1D,IAAIuC,EAAW,EAET,MAAAC,EAAwBC,EAA8B3C,CAAU,EAEhE4C,EAAe,IACfJ,EAAU,GAEdE,EAAsB,QAAQ,EAEvB,IAJiB,GAO1B,IAAIG,EAAO,GACX,MAAMC,EAAa,EAEnBC,EAAQ,IAAM,CACZ,GAAGH,EAAa,EAAU,MAAA,GAGvB,GADHC,GAAQA,EAAO,GAAKC,EACjBD,EAAa,MAAA,GAEV,MAAAG,EAAM,YAAY,MACpBP,IAAqBA,EAAAO,GAEnB,MAAA/B,EAAS,KAAK,IAAI,EAAG,KAAK,OAAO+B,EAAMP,GAAYL,EAAeC,CAAW,CAAC,CAAC,EAErF,OAAGpB,IACDC,EAASD,CAAM,EACJwB,EAAAO,GAGV/B,GAAU,CAACyB,EAAsB,iBAQ/B1C,EAAW,UAAYA,EAAW,aAAeA,EAAW,aAAe,MAC5EA,EAAW,UAAYA,EAAW,cAK/B,EAAA,CACR,CACH,CAUA,MAAMiD,EAA4B,IAE5BC,EAAS,CAAC,QAAS,aAAc,cAAe,SAAS,EACzDC,MAA4B,IAElC,SAASR,EAA8B3C,EAAyB,CAC1D,IAAAoD,EAEJ,GAAID,EAAsB,IAAInD,CAAU,EAuB9BoD,EAAAD,EAAsB,IAAInD,CAAU,MAvBH,CACjCoD,EAAA,CACN,MAAO,EACP,QAAS,IAAM,CACbF,EAAO,QAAiBG,GAAA,CACXrD,EAAA,oBAAoBqD,EAAOC,CAAQ,CAAA,CAC/C,CACH,CAAA,EAGF,MAAMA,EAAW,IAAM,CAClBF,EAAM,qBAA0B,KAAA,aAAaA,EAAM,mBAAmB,EACnEA,EAAA,oBAAsB,KAAK,WAAW,IAAM,CAChDA,EAAM,oBAAsB,QAC3BH,CAAyB,CAAA,EAG9BC,EAAO,QAAiBG,GAAA,CACtBrD,EAAW,iBAAiBqD,EAAOC,EAAU,CAAC,QAAS,GAAK,CAAA,CAC7D,EAEqBH,EAAA,IAAInD,EAAYoD,CAAK,CAAA,CAKvCA,EAAA,QAEN,IAAI3C,EAAU,GAEP,MAAA,CACL,cAAe,IAAM,CAAC,CAAC2C,EAAM,oBAC7B,QAAS,IAAM,CACV3C,IACOA,EAAA,GAEJ2C,EAAA,QAEHA,EAAM,OAAS,IAChBA,EAAM,QAAQ,EACdD,EAAsB,OAAOnD,CAAU,GAE3C,CAAA,CAEJ"}